# Payment Service

---

## Dependencias

Creamos el proyecto desde
[Spring Initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.5.9&packaging=jar&configurationFileFormat=yaml&jvmVersion=21&groupId=dev.magadiflo&artifactId=payment-service&name=payment-service&description=Demo%20project%20for%20Spring%20Boot&packageName=dev.magadiflo.payment.app&dependencies=data-jpa,lombok,postgresql,kafka)
con las siguientes dependencias:

````xml
<!--Spring Boot 3.5.9-->
<!--Java 21-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.kafka</groupId>
        <artifactId>spring-kafka</artifactId>
    </dependency>

    <dependency>
        <groupId>dev.magadiflo</groupId>
        <artifactId>saga-choreography-commons</artifactId>
        <version>1.0.0</version>
    </dependency>
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.kafka</groupId>
        <artifactId>spring-kafka-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

Notar que hemos agregado la dependencia de nuestra librería `saga-choreography-commons`

## Propiedades de configuración

````yml
server:
  port: 8082
  error:
    include-message: always

spring:
  application:
    name: payment-service
  datasource:
    url: jdbc:postgresql://localhost:5434/db_payment_service
    username: payment_service_user
    password: payment_service_pass
  jpa:
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        format_sql: true
  kafka:
    bootstrap-servers: localhost:9092
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer
    consumer:
      group-id: payment-service-group
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: '*'

logging:
  level:
    org.hibernate.SQL: debug
    dev.magadiflo: debug
````

## Clase principal del payment-service

````java
/**
 * Clase principal del Payment Service.
 *
 * Este microservicio es responsable de:
 * - Procesar pagos cuando recibe eventos ORDER_CREATED
 * - Publicar eventos PAYMENT_PROCESSED o PAYMENT_FAILED
 * - Ejecutar compensaciones (refunds) cuando recibe INVENTORY_FAILED
 * - Publicar eventos PAYMENT_REFUNDED al completar la compensación
 */
@SpringBootApplication
public class PaymentServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(PaymentServiceApplication.class, args);
    }

}
````

## Modelos

````java
/**
 * Estados posibles de un pago en el flujo SAGA.
 * <p>
 * Transiciones:
 * - PENDING → PROCESSED (happy path)
 * - PENDING → FAILED (payment falló)
 * - PROCESSED → REFUNDED (compensación cuando inventory falla)
 */
public enum PaymentStatus {
    /**
     * Pago en proceso.
     * Estado inicial al recibir ORDER_CREATED.
     */
    PENDING,

    /**
     * Pago procesado exitosamente.
     * Se publica evento PAYMENT_PROCESSED.
     */
    PROCESSED,

    /**
     * Pago falló.
     * Se publica evento PAYMENT_FAILED.
     */
    FAILED,

    /**
     * Pago reembolsado (compensación).
     * Ocurre cuando Inventory Service reporta fallo.
     * Se publica evento PAYMENT_REFUNDED.
     */
    REFUNDED
}
````

## Entidad Payment

````java
/**
 * Entidad Payment - Representa un pago en el sistema.
 * <p>
 * Almacena el estado del pago a lo largo del flujo SAGA.
 * Esta entidad se crea cuando Payment Service recibe un evento ORDER_CREATED
 * y se actualiza según el resultado del procesamiento.
 */
@ToString
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Setter
@Getter
@Entity
@Table(name = "payments")
public class Payment {
    /**
     * ID técnico - Clave primaria interna.
     * Auto-incremental para eficiencia en índices.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Payment Code - Clave de negocio externa.
     * Identificador único del pago expuesto en eventos y logs.
     * Formato: PAY-{timestamp}-{random} (ej: PAY-1735680000-B7D2)
     */
    @Column(unique = true, nullable = false, length = 50)
    private String paymentCode;

    /**
     * Order Code - Referencia a la orden asociada.
     * NO es FK porque Order está en otra base de datos (Order Service).
     * Se usa para vincular el pago con su orden en eventos.
     */
    @Column(nullable = false, length = 50)
    private String orderCode;

    /**
     * Monto del pago.
     * Debe coincidir con el totalAmount de la orden.
     */
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal amount;

    /**
     * Moneda del pago.
     * Debe coincidir con la moneda de la orden.
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 3)
    private Currency currency;

    /**
     * Estado actual del pago.
     * Se actualiza según el flujo SAGA.
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private PaymentStatus status;

    /**
     * Transaction Code - Identificador de la transacción externa.
     * En un sistema real, sería el ID del gateway de pago (Stripe, PayPal, etc.)
     * En nuestra simulación, lo generamos nosotros.
     * Formato: TXN-{random}
     */
    @Column(length = 100)
    private String transactionCode;

    /**
     * Razón del fallo o reembolso (si aplica).
     * Se llena cuando status = FAILED o REFUNDED.
     */
    @Column(length = 200)
    private String failureReason;

    @CreationTimestamp
    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(nullable = false)
    private LocalDateTime updatedAt;

    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;
        Payment payment = (Payment) o;
        return Objects.equals(this.getPaymentCode(), payment.getPaymentCode());
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(this.getPaymentCode());
    }
}
````

## Repositorio

````java
public interface PaymentRepository extends JpaRepository<Payment, Long> {
    Optional<Payment> findByPaymentCode(String paymentCode);
}
````

## Agregando nuevas constantes

````java

@UtilityClass
public class OrderMessagingConstants {
    public static final String TOPIC_ORDER_CREATED = "order.created";

    public static final String TOPIC_PAYMENT_PROCESSED = "payment.processed";
    public static final String TOPIC_PAYMENT_FAILED = "payment.failed";
    public static final String TOPIC_PAYMENT_REFUNDED = "payment.refunded";

    public static final String TOPIC_INVENTORY_FAILED = "inventory.failed";
}
````

## Configurando topics para payment-service

````java

@Configuration
public class KafkaTopicConfig {
    @Bean
    public NewTopic paymentProcessedTopic() {
        return TopicBuilder.name(OrderMessagingConstants.TOPIC_PAYMENT_PROCESSED).build();
    }

    @Bean
    public NewTopic paymentFailedTopic() {
        return TopicBuilder.name(OrderMessagingConstants.TOPIC_PAYMENT_FAILED).build();
    }

    @Bean
    public NewTopic paymentRefundedTopic() {
        return TopicBuilder.name(OrderMessagingConstants.TOPIC_PAYMENT_REFUNDED).build();
    }
}
````
